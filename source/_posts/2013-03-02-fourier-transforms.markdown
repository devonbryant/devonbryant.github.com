---
layout: post
title: "Fourier Transforms"
date: 2013-03-02 10:50
comments: true
categories: [Fourier Transform, FFT, DSP, Math, MIR]
---

The [Fourier Transform](http://en.wikipedia.org/wiki/Fourier_transform) is one of the most important algorithms in signal processing.  While there is a wealth of information out there on the topic, most of it seems focused solely on the math or optimized implementations of the algorithm.  I have used this algorithm countless times in my research and thought I would share a programmers (and non-math major) perspective on the topic.

<!-- more -->

## The Basic Transform

The Fourier transform is a mapping function that takes a series of samples (or function) in the _time_ domain and maps them into the _frequency_ domain.  The transform is based on the Fourier Series, which is an expansion of a periodic function or signal into the sum of simpler sine and cosine functions.

{% img /images/fourier/fourier_transform.png %}

Looking at the example above, the periodic time data can be described as the sum of 4 _sinusoidal_ functions with frequencies at 110, 220, 330, and 440 hz.  So how does this mapping work?  Unfortunately most descriptions of the Fourier transform (and its inverse) jump right into the following math with little explanation:

{% img center /images/fourier/ft_eq1.png %}

It is often difficult to grasp how we're actually mapping from the time domain _f(x)_ to the frequency domain _F(k)_ (and vice versa) with these equations.  To understand how this works, we need to look at some important properties about the spectrum analysis first.  Let's start by taking two periodic signals _A_ and _B_, where A is our input signal and B is a signal we are generating:

{% img center /images/fourier/siga_sigb.png %}

If we multiply these signals together and sum up the areas underneath the curves, we have:

{% img center /images/fourier/siga_b_mult.png %}

As you can see, about half the area is positive and the other half of the signal is negative and they will cancel each other out.  However, if we multiply two signals together that share a frequency (say A x A), we'll get:

{% img center /images/fourier/siga2.png %}

This tells us that our input signal has significant energy at the frequency of our test (generated) signal.  If we extend this idea, sweeping from frequencies -&infin; to &infin;, we will end up with spikes (or _Dirac_ &#948; functions) where our signals share frequencies and zero energy elsewhere.  This is the basic idea behind Fourier transforms.

## Working with Discrete Data

Since we are often working with small frames of sample data, we can't actually test all frequencies from -&infin; to &infin;.  The Discrete Fourier transform (DFT) is a modification of the Fourier transform that works with discrete sampled data.  Our equations from above become:

{% img center /images/fourier/ft_eq2.png %}

{% img right /images/fourier/sample_freqs.png %}

 The DFT will test evenly spaced frequencies from 0 hz to the _sampling frequency_ (S<sub>r</sub>).  For example, if we have a signal sampled at 44.1 kHz and 1024 samples _N_, the transform will test only the frequencies shown.  The time complexity of the standard DFT is _O(n<sup>2</sup>)_.

## Making it Faster

In 1965, J.W. Cooley and John Turkey came up with a divide and conquer algorithm for calculating a [Fast Fourier Transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform) (FFT) in _O(n log n)_ time.  To this day, this is the most widely used algorithm for Fourier transforms.

The Cooley-Turkey algorithm is often referred to as a _radix-2_ decimation-in-time (DIT) algorithm.  The algorithm works by recursively splitting the data into smaller frames of size N/2 until you are calculating the FFT of a single value, which is the value itself.  For this reason, the length of the input frames must be a power of 2.  On each iteration, the data is split by even and odd indexes.  This interleaving split is where the term "radix-2" comes from.  The term "decimation-in-time" comes from the fact that we are splitting indexes that correspond to time.

Another important property of the DFT is that the outputs for _0 &le; k &lt; N/2_ are identical to the outputs for _N/2 &le; k &lt; N_.  Taking this into account, the above DFT algorithm can be split into the following:

{% img center /images/fourier/fft_eq.png %}

Note that for the odd terms, we were able to pull out the phase factor.  This term is often referred to as the _twiddle factor_.

There are many implementations of the FFT in different languages.  The fastest and most widely used implementation is [FFTW](http://www.fftw.org/), based on highly optimized C code.  One interesting thing about FFTW is that the C code is actually generated by an OCaml program called 'genfft'.  In the next post, I'll explore some implementations of the FFT in Scala.

